## Транслятор и модель
___
* Хоробрых Даниил Евгеньевич, P3216
* asm | risc | neum | mc -> hw | instr | struct | stream | mem | pstr | prob2 | cache
* Базовый вариант
___

### Язык программирования
``` 
<program> ::= <data_section> <code_section>

<data_section> ::= ".data:" <data_definitions>
    
<data_definitions> ::= <data_definition>*
<data_definition>  ::= <label> ":" <data_value>
                     |  <label> ":" "buf" <number>
    
<data_value> ::= <number>
               | <string>

<code_section> ::= ".code:" <instructions>

<instructions> ::= <instruction>*

<instruction> ::= <opcode> <operands> <comment>?
                | <opcode_no_operands> <comment>?
                | <label_only>
    
<opcode> ::= "mov" | "mva" | "st" | "sta" | "ld" | "lda" | "add" | "sub" | "mul" | "div" | "mod" | "inc" | "dec" | "neg" | "cmp" | "test" | "jmp" | "jz" | "jnz" | "jge"
    
<opcode_no_operands> ::= "hlt"

<label_only> ::= <label> ":"

<operands> ::= <operand> <operand>?
<operand> ::= <reg> | <label>
    
<comment> ::= ";" <any_text>
<any_text> ::= <letter> <any_char>*
<any_char> ::= <letter> | <digit> | <symbol>
<symbol> ::= " " | "," | "." | "!" | "?" | "-" | "+" | "*" | "/" | "%" | "&" | "|"

<reg> ::= "r0" | "r1" | "r2" | "r3" | "r4" | "r5" | "r6" | "r7"
<label> ::= <identifier>

<identifier> ::= <letter> <alpanumeric>*

<number> ::= <digit> <digit>*

<string> ::= "\"" <printable_char>* "\""
    
<printable_char> ::= <letter> | <digit> | <symbol>

<letter> ::= [a-zA-Z]
<digit> ::= [0-9]
<alphanumeric> ::= <letter> | <digit>
```

Команды выполняются последовательно, поддерживаются однострочные комментарии, начинающиеся с ```;```. 

**Операции:**

- `mov`: переслать значение из ячейки памяти, обозначенной ```label``` в регистр ```reg```
- `mva`: переслать адрес ячейки памяти, обозначенной `label` в регистр `reg`
- `st label reg`: сохранить значение регистра `reg` в ячейку памяти, обозначенную `label`
- `sta reg1 reg2`: сохранить значение из регистра `reg2` по адресу, содержащемуся в регистре `reg1`
- `ld reg label`: Загрузить значение из ячейки памяти, обозначенной `label`, в регистр `reg`
- `lda reg1 reg2`: Загрузить значение из адреса, содержащегося в регистре `reg2`, в регистр `reg1`
- `add reg1 reg2`: Добавить значения из регистров `reg1` и `reg2`, результат сохранить в `reg1`
- `sub reg1 reg2`: Вычесть значение регистра `reg2` из значения регистра `reg1`, результат сохранить в `reg1`
- `mul reg1 reg2`: Умножить значения из регистров `reg1` и `reg2`, результат сохранить в `reg1`.
- `div reg1 reg2`: Разделить значение регистра `reg1` на значение регистра `reg2`, результат сохранить в `reg1`.
- `mod reg1 reg2`: Вычислить остаток от деления значения регистра `reg1` на значение регистра `reg2`, результат сохранить в `reg1`.
- `inc reg`: Увеличить значение в регистре `reg` на 1.
- `dec reg`: Уменьшить значение в регистре `reg` на 1.
- `neg reg`: Изменить знак значения в регистре `reg`.
- `CMP reg1 reg2`: Сравнить значения в регистрах `reg1` и `reg2`.
- `TEST reg1 reg2`: Побитовое И значений в регистрах `reg1` и `reg2`.
- `JMP label`: Перейти к метке `label`.
- `jz label`: Перейти к метке `label`, если результат предыдущей команды сравнения был нулевым.
- `jnz label`: Перейти к метке `label`, если результат предыдущей команды сравнения был ненулевым.
- `jge label`: Перейти к метке `label`, если результат предыдущей команды сравнения был больше или равен нулю.
- `hlt`: Остановить выполнение программы.

Метки для переходов определяются на отдельных строчках:
```
label:
    inc r0
```

И в другом месте (неважно, до или после определения) сослаться на эту метку:
```jmp label```

Транслятор поставит на место использования метки адрес той инструкции, перед которой она определена (или ячейку памяти, в которой находится этот адрес для команд `mva`, `lda`, `sta`).

В программе не может быть дублирующихся меток, определенных в разных местах с одним именем

Пример кода приведен в директории asm.
___

### Организация памяти
- Архитектура памяти - Фон-Неймановская
- Размер машинного слова - 32 бита
- Адресация - абсолютная
- Данные в памяти хранятся в следующем виде:

| address | memory            |
|---------|-------------------|
| 0       | jmp first_address |
| 1       | input address     |
| 2       | output address    |
| 3       | data              | 
| ...     | ...               |
| n - 1   | data              |
| n       | command #1        |
| n + 1   | command #2        |
| ...     | ...               |

За организацию статической памяти отвечает транслятор, выделяя требуемые метки и буфферы во время перевода кода в машинный код. Неиспользуемые ячейки памяти инициализируются `0`.

- В `0` ячейке располагается команда `jmp first_address`, которая отвечает за переход счетчика команд к первой команде (в машине программа начинает исполняться всегда с `0` адреса).
- Затем идут 2 ячейки с адресами `1` и `2` которые в памяти не используются, а отвечают за перенаправление данных из/в внешние устройства (`input address` и `output_address` соответственно). В программе реализуется memory-mapped архитектура взаимодействия с внешними устройствами.
- Начиная с `3` ячейки располагаются переменные, определенные в секции `.data`, а также адреса для перехода по меткам из кода. Все данные в памяти хранятся в целочисленном виде, строки хранятся посимвольно и перед записью преобразуются в ASCII-код. Хранение строк реализовано в формате `pstr` (сначала загружается длина строки, затем в следующих `n` строках - символы).
- После всех данных с начинают располагаться инструкции программы из секции `.code`. 

___
### Система команд

Особенности процессора:
* Машинное слово - 32 бита, знаковое
* Доступ к памяти осуществляется по адресу, хранящемуся в специальном регистре `address_register`. Установка адреса осуществляется путем зашелкивания или из `ALU`, или из регистра `program_counter`. Из памяти данные попадают в регистр `data_register`.
* Обработка данных осуществляется между регистрами с помощью `ALU`, данные в регистр попадают из `data_register`.
* Поток управления:
  * Инкрементирование текущего значения в `program_counter`
  * Переход на адрес, расположенный в операнде текущей программы с помощью безусловного (`jmp`) и условных (`jz`, `jnz`, `jge`) переходов.

#### Набор инструкций
| Инструкция | Кол-во тактов |
|------------|---------------|
| MOV        | 1             |
| MVA        | 1             |
| ST         | 3             |
| STA        | 3             |
| LD         | 3             |
| LDA        | 3             |
| ADD        | 1             |
| SUB        | 1             |
| MUL        | 1             |
| DIV        | 1             |
| INC        | 1             |
| DEC        | 1             |
| MOD        | 1             |
| NEG        | 1             |
| CMP        | 1             |
| TEST       | 1             |
| JMP        | 1             |
| JZ         | 1             |
| JNZ        | 1             |
| JGE        | 1             |
| HLT        | 1             |

Также перед каждой инструкцией выполняется цикл выборки инструкции, который занимает `1` такт

Подробное описание инструкций приведено в пункте Язык программирования.

#### Кодирование инструкций
- Машинный код сериализуется в список JSON
- Один элемент списка - одна инструкция

Пример:
```json
[
  {
        "index": 0,
        "opcode": "jmp",
        "terms": [
            101
        ]
    }
]
```

- `index`: индекс команды внутри программы
- `opcode`: строка с кодом операции
- `terms`: список аргументов команды (может быть пустым)

Тип данных инструкций - `Command`, тип данных opcode - `Opcode` (Описаны в модуле isa).
___

### Транслятор



